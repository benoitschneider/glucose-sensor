#include "main.h"
#include "i2c_driver.h"
#include "ads1115_driver.h"
#include "config.h"

// Include your MCU's specific HAL header here
// Example for STM32Cube HAL:
#include "stm32l4xx_hal.h" // Adjust based on your specific MCU family

// Global I2C handle (if using STM32 HAL, typically defined in main.c or stm32l4xx_hal_msp.c)
I2C_HandleTypeDef hi2c1; // Example: This handle must be initialized by your HAL setup

// --- MCU Specific Initialization Functions (placeholders) ---
// These functions would typically be generated by an MCU configuration tool (e.g., STM32CubeMX)
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_I2C1_Init(void);

// --- Main Application Code ---
int main(void)
{
    // MCU HAL initialization
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_I2C1_Init(); // Initialize the I2C peripheral

    // Initialize the I2C driver (optional, as HAL_I2C_Init does most of the work)
    // I2C_Driver_Init(); // This function mostly checks HAL state, actual init is MX_I2C1_Init

    // Initialize the ADS1115 driver
    ADS1115_Status_t ads_status = ADS1115_Init();
    if (ads_status != ADS1115_OK)
    {
        // Handle ADS1115 initialization error (e.g., blink an LED, log error)
        while (1) { /* Error loop */ }
    }

    // Configure ADS1115 for single-shot conversion on AIN0 to GND, PGA +/-4.096V, 128SPS
    ads_status = ADS1115_Configure(
        ADS1115_MUX_P0_NG,      // AIN0 to GND
        ADS1115_PGA_4_096V,     // +/-4.096V Full Scale Range
        ADS1115_DR_128SPS,      // 128 Samples Per Second
        ADS1115_MODE_SINGLESHOT // Single-shot mode
    );
    if (ads_status != ADS1115_OK)
    {
        // Handle configuration error
        while (1) { /* Error loop */ }
    }

    int16_t adc_raw_value;
    float adc_voltage;
    bool conversion_done;

    while (1)
    {
        // Start a single conversion
        ads_status = ADS1115_StartConversion();
        if (ads_status != ADS1115_OK)
        {
            // Handle error, maybe retry or reset I2C
            HAL_Delay(100); // Wait a bit before retrying
            continue;
        }

        // Wait for conversion to complete (polling example)
        // In a real application, you might use an interrupt from the ALERT/RDY pin
        do
        {
            ads_status = ADS1115_IsConversionComplete(&conversion_done);
            if (ads_status != ADS1115_OK)
            {
                // Handle error
                break;
            }
            HAL_Delay(1); // Small delay to prevent busy-waiting too aggressively
        } while (!conversion_done);

        if (ads_status == ADS1115_OK)
        {
            // Read the conversion result
            ads_status = ADS1115_ReadConversionResult(&adc_raw_value);
            if (ads_status == ADS1115_OK)
            {
                // Convert raw value to voltage
                adc_voltage = ADS1115_RawToVoltage(adc_raw_value, ADS1115_PGA_4_096V);

                // Here you would use adc_voltage (e.g., print to UART, process sensor data)
                // For demonstration, we'll just keep looping.
                // Example: Print to debug console if available
                // printf("ADC Raw: %d, Voltage: %.3fV\n", adc_raw_value, adc_voltage);
            }
        }

        HAL_Delay(1000); // Wait for 1 second before next conversion (1Hz acquisition)
    }
}

// --- MCU Specific HAL/GPIO/Clock Implementations (placeholders) ---
// These functions are typically generated by your MCU's configuration tool.
// Replace with actual implementations for your specific microcontroller.
void SystemClock_Config(void)
{
    // Example for STM32L4xx: Configure system clock (HSI, PLL, etc.)
    // This would be replaced by your actual clock configuration.
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
    RCC_OscInitStruct.PLL.PLLM = 1;
    RCC_OscInitStruct.PLL.PLLN = 10;
    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
    RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
    RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
    {
        Error_Handler();
    }

    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
    {
        Error_Handler();
    }
}

static void MX_GPIO_Init(void)
{
    // Example: Initialize GPIO for I2C pins, and maybe an error LED
    // This would be replaced by your actual GPIO configuration.
    __HAL_RCC_GPIOB_CLK_ENABLE(); // Example: Enable GPIOB clock for I2C1 pins
    // Configure GPIO for I2C SCL/SDA as Alternate Function Open-Drain
    // (Detailed configuration depends on your MCU and specific pins)
}

static void MX_I2C1_Init(void)
{
    // Example for STM32L4xx: Initialize I2C1 peripheral
    // This would be replaced by your actual I2C configuration.
    hi2c1.Instance = I2C1;
    hi2c1.Init.Timing = 0x10900D14; // Example timing for 100kHz or 400kHz, depends on clock
    hi2c1.Init.OwnAddress1 = 0;
    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
    hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
    hi2c1.Init.OwnAddress2 = 0;
    hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
    if (HAL_I2C_Init(&hi2c1) != HAL_OK)
    {
        Error_Handler();
    }
    /** Configure Analogue filter
    */
    if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
    {
        Error_Handler();
    }
    /** Configure Digital filter
    */
    if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
    {
        Error_Handler();
    }
}

void Error_Handler(void)
{
    // User can add his own implementation to report the HAL error return state
    while (1)
    {
        // Example: Blink an LED to indicate error
        // HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
        // HAL_Delay(100);
    }
}
